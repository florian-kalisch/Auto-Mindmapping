{"version":3,"file":"static/js/154.06fc368a.chunk.js","mappings":"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","sources":["../node_modules/lodash-es/clone.js","../node_modules/dagre-d3-es/src/graphlib/json.js","../node_modules/mermaid/src/dagre-wrapper/mermaid-graphlib.js","../node_modules/mermaid/src/dagre-wrapper/clusters.js","../node_modules/mermaid/src/dagre-wrapper/index.js"],"sourcesContent":["import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nexport default clone;\n","import * as _ from 'lodash-es';\nimport { Graph } from './graph.js';\n\nexport { write, read };\n\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound(),\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g),\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\n\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function (v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = { v: v };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\n\nfunction writeEdges(g) {\n  return _.map(g.edges(), function (e) {\n    var edgeValue = g.edge(e);\n    var edge = { v: e.v, w: e.w };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\n\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function (entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function (entry) {\n    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);\n  });\n  return g;\n}\n","/** Decorates with functions required by mermaids dagre-wrapper. */\nimport { log } from '../logger';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport * as graphlib from 'dagre-d3-es/src/graphlib/index.js';\n\nexport let clusterDb = {};\nlet descendants = {};\nlet parents = {};\n\nexport const clear = () => {\n  descendants = {};\n  parents = {};\n  clusterDb = {};\n};\n\nconst isDescendant = (id, ancenstorId) => {\n  // if (id === ancenstorId) return true;\n\n  log.trace('In isDecendant', ancenstorId, ' ', id, ' = ', descendants[ancenstorId].includes(id));\n  if (descendants[ancenstorId].includes(id)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst edgeInCluster = (edge, clusterId) => {\n  log.info('Decendants of ', clusterId, ' is ', descendants[clusterId]);\n  log.info('Edge is ', edge);\n  // Edges to/from the cluster is not in the cluster, they are in the parent\n  if (edge.v === clusterId) {\n    return false;\n  }\n  if (edge.w === clusterId) {\n    return false;\n  }\n\n  if (!descendants[clusterId]) {\n    log.debug('Tilt, ', clusterId, ',not in decendants');\n    return false;\n  }\n  return (\n    descendants[clusterId].includes(edge.v) ||\n    isDescendant(edge.v, clusterId) ||\n    isDescendant(edge.w, clusterId) ||\n    descendants[clusterId].includes(edge.w)\n  );\n};\n\nconst copy = (clusterId, graph, newGraph, rootId) => {\n  log.warn(\n    'Copying children of ',\n    clusterId,\n    'root',\n    rootId,\n    'data',\n    graph.node(clusterId),\n    rootId\n  );\n  const nodes = graph.children(clusterId) || [];\n\n  // Include cluster node if it is not the root\n  if (clusterId !== rootId) {\n    nodes.push(clusterId);\n  }\n\n  log.warn('Copying (nodes) clusterId', clusterId, 'nodes', nodes);\n\n  nodes.forEach((node) => {\n    if (graph.children(node).length > 0) {\n      copy(node, graph, newGraph, rootId);\n    } else {\n      const data = graph.node(node);\n      log.info('cp ', node, ' to ', rootId, ' with parent ', clusterId); //,node, data, ' parent is ', clusterId);\n      newGraph.setNode(node, data);\n      if (rootId !== graph.parent(node)) {\n        log.warn('Setting parent', node, graph.parent(node));\n        newGraph.setParent(node, graph.parent(node));\n      }\n\n      if (clusterId !== rootId && node !== clusterId) {\n        log.debug('Setting parent', node, clusterId);\n        newGraph.setParent(node, clusterId);\n      } else {\n        log.info('In copy ', clusterId, 'root', rootId, 'data', graph.node(clusterId), rootId);\n        log.debug(\n          'Not Setting parent for node=',\n          node,\n          'cluster!==rootId',\n          clusterId !== rootId,\n          'node!==clusterId',\n          node !== clusterId\n        );\n      }\n      const edges = graph.edges(node);\n      log.debug('Copying Edges', edges);\n      edges.forEach((edge) => {\n        log.info('Edge', edge);\n        const data = graph.edge(edge.v, edge.w, edge.name);\n        log.info('Edge data', data, rootId);\n        try {\n          // Do not copy edges in and out of the root cluster, they belong to the parent graph\n          if (edgeInCluster(edge, rootId)) {\n            log.info('Copying as ', edge.v, edge.w, data, edge.name);\n            newGraph.setEdge(edge.v, edge.w, data, edge.name);\n            log.info('newGraph edges ', newGraph.edges(), newGraph.edge(newGraph.edges()[0]));\n          } else {\n            log.info(\n              'Skipping copy of edge ',\n              edge.v,\n              '-->',\n              edge.w,\n              ' rootId: ',\n              rootId,\n              ' clusterId:',\n              clusterId\n            );\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n    log.debug('Removing node', node);\n    graph.removeNode(node);\n  });\n};\nexport const extractDescendants = (id, graph) => {\n  // log.debug('Extracting ', id);\n  const children = graph.children(id);\n  let res = [...children];\n\n  for (const child of children) {\n    parents[child] = id;\n    res = [...res, ...extractDescendants(child, graph)];\n  }\n\n  return res;\n};\n\n/**\n * Validates the graph, checking that all parent child relation points to existing nodes and that\n * edges between nodes also ia correct. When not correct the function logs the discrepancies.\n *\n * @param graph\n */\nexport const validate = (graph) => {\n  const edges = graph.edges();\n  log.trace('Edges: ', edges);\n  for (const edge of edges) {\n    if (graph.children(edge.v).length > 0) {\n      log.trace('The node ', edge.v, ' is part of and edge even though it has children');\n      return false;\n    }\n    if (graph.children(edge.w).length > 0) {\n      log.trace('The node ', edge.w, ' is part of and edge even though it has children');\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Finds a child that is not a cluster. When faking an edge between a node and a cluster.\n *\n * @param id\n * @param {any} graph\n */\nexport const findNonClusterChild = (id, graph) => {\n  // const node = graph.node(id);\n  log.trace('Searching', id);\n  // const children = graph.children(id).reverse();\n  const children = graph.children(id); //.reverse();\n  log.trace('Searching children of id ', id, children);\n  if (children.length < 1) {\n    log.trace('This is a valid node', id);\n    return id;\n  }\n  for (const child of children) {\n    const _id = findNonClusterChild(child, graph);\n    if (_id) {\n      log.trace('Found replacement for', id, ' => ', _id);\n      return _id;\n    }\n  }\n};\n\nconst getAnchorId = (id) => {\n  if (!clusterDb[id]) {\n    return id;\n  }\n  // If the cluster has no external connections\n  if (!clusterDb[id].externalConnections) {\n    return id;\n  }\n\n  // Return the replacement node\n  if (clusterDb[id]) {\n    return clusterDb[id].id;\n  }\n  return id;\n};\n\nexport const adjustClustersAndEdges = (graph, depth) => {\n  if (!graph || depth > 10) {\n    log.debug('Opting out, no graph ');\n    return;\n  } else {\n    log.debug('Opting in, graph ');\n  }\n  // Go through the nodes and for each cluster found, save a replacement node, this can be used when\n  // faking a link to a cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    if (children.length > 0) {\n      log.warn(\n        'Cluster identified',\n        id,\n        ' Replacement id in edges: ',\n        findNonClusterChild(id, graph)\n      );\n      descendants[id] = extractDescendants(id, graph);\n      clusterDb[id] = { id: findNonClusterChild(id, graph), clusterData: graph.node(id) };\n    }\n  });\n\n  // Check incoming and outgoing edges for each cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    const edges = graph.edges();\n    if (children.length > 0) {\n      log.debug('Cluster identified', id, descendants);\n      edges.forEach((edge) => {\n        // log.debug('Edge, decendants: ', edge, decendants[id]);\n\n        // Check if any edge leaves the cluster (not the actual cluster, that's a link from the box)\n        if (edge.v !== id && edge.w !== id) {\n          // Any edge where either the one of the nodes is descending to the cluster but not the other\n          // if (decendants[id].indexOf(edge.v) < 0 && decendants[id].indexOf(edge.w) < 0) {\n\n          const d1 = isDescendant(edge.v, id);\n          const d2 = isDescendant(edge.w, id);\n\n          // d1 xor d2 - if either d1 is true and d2 is false or the other way around\n          if (d1 ^ d2) {\n            log.warn('Edge: ', edge, ' leaves cluster ', id);\n            log.warn('Decendants of XXX ', id, ': ', descendants[id]);\n            clusterDb[id].externalConnections = true;\n          }\n        }\n      });\n    } else {\n      log.debug('Not a cluster ', id, descendants);\n    }\n  });\n\n  // For clusters with incoming and/or outgoing edges translate those edges to a real node\n  // in the cluster in order to fake the edge\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(graph.edge(e)));\n\n    let v = e.v;\n    let w = e.w;\n    // Check if link is either from or to a cluster\n    log.warn(\n      'Fix XXX',\n      clusterDb,\n      'ids:',\n      e.v,\n      e.w,\n      'Translating: ',\n      clusterDb[e.v],\n      ' --- ',\n      clusterDb[e.w]\n    );\n    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {\n      log.warn('Fixing and trixing link to self - removing XXX', e.v, e.w, e.name);\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      const specialId = e.w + '---' + e.v;\n      graph.setNode(specialId, {\n        domId: specialId,\n        id: specialId,\n        labelStyle: '',\n        labelText: edge.label,\n        padding: 0,\n        shape: 'labelRect',\n        style: '',\n      });\n      const edge1 = JSON.parse(JSON.stringify(edge));\n      const edge2 = JSON.parse(JSON.stringify(edge));\n      edge1.label = '';\n      edge1.arrowTypeEnd = 'none';\n      edge2.label = '';\n      edge1.fromCluster = e.v;\n      edge2.toCluster = e.v;\n\n      graph.setEdge(v, specialId, edge1, e.name + '-cyclic-special');\n      graph.setEdge(specialId, w, edge2, e.name + '-cyclic-special');\n    } else if (clusterDb[e.v] || clusterDb[e.w]) {\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      if (v !== e.v) {\n        edge.fromCluster = e.v;\n      }\n      if (w !== e.w) {\n        edge.toCluster = e.w;\n      }\n      log.warn('Fix Replacing with XXX', v, w, e.name);\n      graph.setEdge(v, w, edge, e.name);\n    }\n  });\n  log.warn('Adjusted Graph', graphlibJson.write(graph));\n  extractor(graph, 0);\n\n  log.trace(clusterDb);\n\n  // Remove references to extracted cluster\n  // graph.edges().forEach(edge => {\n  //   if (isDecendant(edge.v, clusterId) || isDecendant(edge.w, clusterId)) {\n  //     graph.removeEdge(edge);\n  //   }\n  // });\n};\n\nexport const extractor = (graph, depth) => {\n  log.warn('extractor - ', depth, graphlibJson.write(graph), graph.children('D'));\n  if (depth > 10) {\n    log.error('Bailing out');\n    return;\n  }\n  // For clusters without incoming and/or outgoing edges, create a new cluster-node\n  // containing the nodes and edges in the custer in a new graph\n  // for (let i = 0;)\n  let nodes = graph.nodes();\n  let hasChildren = false;\n  for (const node of nodes) {\n    const children = graph.children(node);\n    hasChildren = hasChildren || children.length > 0;\n  }\n\n  if (!hasChildren) {\n    log.debug('Done, no node has children', graph.nodes());\n    return;\n  }\n  // const clusters = Object.keys(clusterDb);\n  // clusters.forEach(clusterId => {\n  log.debug('Nodes = ', nodes, depth);\n  for (const node of nodes) {\n    log.debug(\n      'Extracting node',\n      node,\n      clusterDb,\n      clusterDb[node] && !clusterDb[node].externalConnections,\n      !graph.parent(node),\n      graph.node(node),\n      graph.children('D'),\n      ' Depth ',\n      depth\n    );\n    // Note that the node might have been removed after the Object.keys call so better check\n    // that it still is in the game\n    if (!clusterDb[node]) {\n      // Skip if the node is not a cluster\n      log.debug('Not a cluster', node, depth);\n      // break;\n    } else if (\n      !clusterDb[node].externalConnections &&\n      // !graph.parent(node) &&\n      graph.children(node) &&\n      graph.children(node).length > 0\n    ) {\n      log.warn(\n        'Cluster without external connections, without a parent and with children',\n        node,\n        depth\n      );\n\n      const graphSettings = graph.graph();\n      let dir = graphSettings.rankdir === 'TB' ? 'LR' : 'TB';\n      if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {\n        dir = clusterDb[node].clusterData.dir;\n        log.warn('Fixing dir', clusterDb[node].clusterData.dir, dir);\n      }\n\n      const clusterGraph = new graphlib.Graph({\n        multigraph: true,\n        compound: true,\n      })\n        .setGraph({\n          rankdir: dir, // Todo: set proper spacing\n          nodesep: 50,\n          ranksep: 50,\n          marginx: 8,\n          marginy: 8,\n        })\n        .setDefaultEdgeLabel(function () {\n          return {};\n        });\n\n      log.warn('Old graph before copy', graphlibJson.write(graph));\n      copy(node, graph, clusterGraph, node);\n      graph.setNode(node, {\n        clusterNode: true,\n        id: node,\n        clusterData: clusterDb[node].clusterData,\n        labelText: clusterDb[node].labelText,\n        graph: clusterGraph,\n      });\n      log.warn('New graph after copy node: (', node, ')', graphlibJson.write(clusterGraph));\n      log.debug('Old graph after copy', graphlibJson.write(graph));\n    } else {\n      log.warn(\n        'Cluster ** ',\n        node,\n        ' **not meeting the criteria !externalConnections:',\n        !clusterDb[node].externalConnections,\n        ' no parent: ',\n        !graph.parent(node),\n        ' children ',\n        graph.children(node) && graph.children(node).length > 0,\n        graph.children('D'),\n        depth\n      );\n      log.debug(clusterDb);\n    }\n  }\n\n  nodes = graph.nodes();\n  log.warn('New list of nodes', nodes);\n  for (const node of nodes) {\n    const data = graph.node(node);\n    log.warn(' Now next level', node, data);\n    if (data.clusterNode) {\n      extractor(data.graph, depth + 1);\n    }\n  }\n};\n\nconst sorter = (graph, nodes) => {\n  if (nodes.length === 0) {\n    return [];\n  }\n  let result = Object.assign(nodes);\n  nodes.forEach((node) => {\n    const children = graph.children(node);\n    const sorted = sorter(graph, children);\n    result = [...result, ...sorted];\n  });\n\n  return result;\n};\n\nexport const sortNodesByHierarchy = (graph) => sorter(graph, graph.children());\n","import intersectRect from './intersect/intersect-rect';\nimport { log } from '../logger';\nimport createLabel from './createLabel';\nimport { select } from 'd3';\nimport { getConfig } from '../config';\nimport { evaluate } from '../diagrams/common/common';\n\nconst rect = (parent, node) => {\n  log.trace('Creating subgraph rect for ', node.id, node);\n\n  // Add outer g element\n  const shapeSvg = parent\n    .insert('g')\n    .attr('class', 'cluster' + (node.class ? ' ' + node.class : ''))\n    .attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n\n  const text = label\n    .node()\n    .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;\n  if (node.width <= bbox.width + padding) {\n    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  log.trace('Data ', node, JSON.stringify(node));\n  // center the rect around its coordinate\n  rect\n    .attr('style', node.style)\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - width / 2)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width)\n    .attr('height', node.height + padding);\n\n  // Center the label\n  label.attr(\n    'transform',\n    // This puts the labal on top of the box instead of inside it\n    // 'translate(' + (node.x - bbox.width / 2) + ', ' + (node.y - node.height / 2 - bbox.height) + ')'\n    'translate(' + (node.x - bbox.width / 2) + ', ' + (node.y - node.height / 2) + ')'\n  );\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\n/**\n * Non visible cluster where the note is group with its\n *\n * @param {any} parent\n * @param {any} node\n * @returns {any} ShapeSvg\n */\nconst noteGroup = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', 'note-cluster').attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding)\n    .attr('fill', 'none');\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\nconst roundedWithTitle = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n  const innerRect = shapeSvg.append('rect');\n\n  const text = label\n    .node()\n    .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n  bbox = text.getBBox();\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;\n  if (node.width <= bbox.width + node.padding) {\n    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'outer')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding);\n  innerRect\n    .attr('class', 'inner')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding + bbox.height - 1)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding - bbox.height - 3);\n\n  // Center the label\n  label.attr(\n    'transform',\n    'translate(' +\n      (node.x - bbox.width / 2) +\n      ', ' +\n      (node.y -\n        node.height / 2 -\n        node.padding / 3 +\n        (evaluate(getConfig().flowchart.htmlLabels) ? 5 : 3)) +\n      ')'\n  );\n\n  const rectBox = rect.node().getBBox();\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst divider = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'divider')\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding);\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.diff = -node.padding / 2;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst shapes = { rect, roundedWithTitle, noteGroup, divider };\n\nlet clusterElems = {};\n\nexport const insertCluster = (elem, node) => {\n  log.trace('Inserting cluster');\n  const shape = node.shape || 'rect';\n  clusterElems[node.id] = shapes[shape](elem, node);\n};\nexport const getClusterTitleWidth = (elem, node) => {\n  const label = createLabel(node.labelText, node.labelStyle, undefined, true);\n  elem.node().appendChild(label);\n  const width = label.getBBox().width;\n  elem.node().removeChild(label);\n  return width;\n};\n\nexport const clear = () => {\n  clusterElems = {};\n};\n\nexport const positionCluster = (node) => {\n  log.info('Position cluster (' + node.id + ', ' + node.x + ', ' + node.y + ')');\n  const el = clusterElems[node.id];\n\n  el.attr('transform', 'translate(' + node.x + ', ' + node.y + ')');\n};\n","import { layout as dagreLayout } from 'dagre-d3-es/src/dagre/index.js';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport insertMarkers from './markers';\nimport { updateNodeBounds } from './shapes/util';\nimport {\n  clear as clearGraphlib,\n  clusterDb,\n  adjustClustersAndEdges,\n  findNonClusterChild,\n  sortNodesByHierarchy,\n} from './mermaid-graphlib';\nimport { insertNode, positionNode, clear as clearNodes, setNodeElem } from './nodes';\nimport { insertCluster, clear as clearClusters } from './clusters';\nimport { insertEdgeLabel, positionEdgeLabel, insertEdge, clear as clearEdges } from './edges';\nimport { log } from '../logger';\n\nconst recursiveRender = (_elem, graph, diagramtype, parentCluster) => {\n  log.info('Graph in recursive render: XXX', graphlibJson.write(graph), parentCluster);\n  const dir = graph.graph().rankdir;\n  log.trace('Dir in recursive render - dir:', dir);\n\n  const elem = _elem.insert('g').attr('class', 'root');\n  if (!graph.nodes()) {\n    log.info('No nodes found for', graph);\n  } else {\n    log.info('Recursive render XXX', graph.nodes());\n  }\n  if (graph.edges().length > 0) {\n    log.trace('Recursive edges', graph.edge(graph.edges()[0]));\n  }\n  const clusters = elem.insert('g').attr('class', 'clusters');\n  const edgePaths = elem.insert('g').attr('class', 'edgePaths');\n  const edgeLabels = elem.insert('g').attr('class', 'edgeLabels');\n  const nodes = elem.insert('g').attr('class', 'nodes');\n\n  // Insert nodes, this will insert them into the dom and each node will get a size. The size is updated\n  // to the abstract node and is later used by dagre for the layout\n  graph.nodes().forEach(function (v) {\n    const node = graph.node(v);\n    if (parentCluster !== undefined) {\n      const data = JSON.parse(JSON.stringify(parentCluster.clusterData));\n      // data.clusterPositioning = true;\n      log.info('Setting data for cluster XXX (', v, ') ', data, parentCluster);\n      graph.setNode(parentCluster.id, data);\n      if (!graph.parent(v)) {\n        log.trace('Setting parent', v, parentCluster.id);\n        graph.setParent(v, parentCluster.id, data);\n      }\n    }\n    log.info('(Insert) Node XXX' + v + ': ' + JSON.stringify(graph.node(v)));\n    if (node && node.clusterNode) {\n      // const children = graph.children(v);\n      log.info('Cluster identified', v, node.width, graph.node(v));\n      const o = recursiveRender(nodes, node.graph, diagramtype, graph.node(v));\n      const newEl = o.elem;\n      updateNodeBounds(node, newEl);\n      node.diff = o.diff || 0;\n      log.info('Node bounds (abc123)', v, node, node.width, node.x, node.y);\n      setNodeElem(newEl, node);\n\n      log.warn('Recursive render complete ', newEl, node);\n    } else {\n      if (graph.children(v).length > 0) {\n        // This is a cluster but not to be rendered recursively\n        // Render as before\n        log.info('Cluster - the non recursive path XXX', v, node.id, node, graph);\n        log.info(findNonClusterChild(node.id, graph));\n        clusterDb[node.id] = { id: findNonClusterChild(node.id, graph), node };\n        // insertCluster(clusters, graph.node(v));\n      } else {\n        log.info('Node - the non recursive path', v, node.id, node);\n        insertNode(nodes, graph.node(v), dir);\n      }\n    }\n  });\n\n  // Insert labels, this will insert them into the dom so that the width can be calculated\n  // Also figure out which edges point to/from clusters and adjust them accordingly\n  // Edges from/to clusters really points to the first child in the cluster.\n  // TODO: pick optimal child in the cluster to us as link anchor\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e.v, e.w, e.name);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ', e, ' ', JSON.stringify(graph.edge(e)));\n\n    // Check if link is either from or to a cluster\n    log.info('Fix', clusterDb, 'ids:', e.v, e.w, 'Translateing: ', clusterDb[e.v], clusterDb[e.w]);\n    insertEdgeLabel(edgeLabels, edge);\n  });\n\n  graph.edges().forEach(function (e) {\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n  });\n  log.info('#############################################');\n  log.info('###                Layout                 ###');\n  log.info('#############################################');\n  log.info(graph);\n  dagreLayout(graph);\n  log.info('Graph after layout:', graphlibJson.write(graph));\n  // Move the nodes to the correct place\n  let diff = 0;\n  sortNodesByHierarchy(graph).forEach(function (v) {\n    const node = graph.node(v);\n    log.info('Position ' + v + ': ' + JSON.stringify(graph.node(v)));\n    log.info(\n      'Position ' + v + ': (' + node.x,\n      ',' + node.y,\n      ') width: ',\n      node.width,\n      ' height: ',\n      node.height\n    );\n    if (node && node.clusterNode) {\n      // clusterDb[node.id].node = node;\n\n      positionNode(node);\n    } else {\n      // Non cluster node\n      if (graph.children(v).length > 0) {\n        // A cluster in the non-recursive way\n        // positionCluster(node);\n        insertCluster(clusters, node);\n        clusterDb[node.id].node = node;\n      } else {\n        positionNode(node);\n      }\n    }\n  });\n\n  // Move the edge labels to the correct place after layout\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(edge), edge);\n\n    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph);\n    positionEdgeLabel(edge, paths);\n  });\n\n  graph.nodes().forEach(function (v) {\n    const n = graph.node(v);\n    log.info(v, n.type, n.diff);\n    if (n.type === 'group') {\n      diff = n.diff;\n    }\n  });\n  return { elem, diff };\n};\n\nexport const render = (elem, graph, markers, diagramtype, id) => {\n  insertMarkers(elem, markers, diagramtype, id);\n  clearNodes();\n  clearEdges();\n  clearClusters();\n  clearGraphlib();\n\n  log.warn('Graph at first:', graphlibJson.write(graph));\n  adjustClustersAndEdges(graph);\n  log.warn('Graph after:', graphlibJson.write(graph));\n  // log.warn('Graph ever  after:', graphlibJson.write(graph.node('A').graph));\n  recursiveRender(elem, graph, diagramtype);\n};\n\n// const shapeDefinitions = {};\n// export const addShape = ({ shapeType: fun }) => {\n//   shapeDefinitions[shapeType] = fun;\n// };\n\n// const arrowDefinitions = {};\n// export const addArrow = ({ arrowType: fun }) => {\n//   arrowDefinitions[arrowType] = fun;\n// };\n"],"names":["value","baseClone","write","g","json","options","directed","isDirected","multigraph","isMultigraph","compound","isCompound","nodes","writeNodes","edges","writeEdges","_","graph","v","nodeValue","node","parent","e","edgeValue","edge","w","name","clusterDb","descendants","parents","isDescendant","id","ancenstorId","log","trace","includes","copy","clusterId","newGraph","rootId","warn","children","push","forEach","length","data","info","setNode","setParent","debug","data2","edgeInCluster","setEdge","error","removeNode","extractDescendants","_step","res","_toConsumableArray","_iterator","_createForOfIteratorHelper","s","n","done","child","concat","err","f","findNonClusterChild","_step2","_iterator2","_id","getAnchorId","externalConnections","adjustClustersAndEdges","depth","clusterData","JSON","stringify","removeEdge","specialId","domId","labelStyle","labelText","label","padding","shape","style","edge1","parse","edge2","arrowTypeEnd","fromCluster","toCluster","graphlibJson","extractor","_step3","hasChildren","_iterator3","_step4","_iterator4","dir","rankdir","clusterGraph","graphlib","setGraph","nodesep","ranksep","marginx","marginy","setDefaultEdgeLabel","clusterNode","_step5","_iterator5","sorter","result","Object","assign","sorted","sortNodesByHierarchy","shapes","rect","shapeSvg","insert","attr","class","rect2","text","appendChild","createLabel","bbox","getBBox","evaluate","getConfig","flowchart","htmlLabels","div","dv","select","getBoundingClientRect","width","height","halfPadding","diff","rx","ry","x","y","rectBox","intersect","point","intersectRect","roundedWithTitle","classes","innerRect","append","noteGroup","divider","clusterElems","recursiveRender","_elem","diagramtype","parentCluster","elem","clusters","edgePaths","edgeLabels","o","newEl","updateNodeBounds","setNodeElem","insertNode","insertEdgeLabel","layout","positionNode","insertCluster","paths","insertEdge","positionEdgeLabel","type","render","markers","insertMarkers","clear$2","clear$3"],"sourceRoot":""}